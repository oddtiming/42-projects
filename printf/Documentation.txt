- printf

- "-0." flags :
	- "-" : "A negative field width flag; the converted value is to be left adjusted
			on the field boundary.  Except for n conversions, the converted value is
			padded on the right with blanks, rather than on the left with blanks or
			zeros.  A - overrides a 0 if both are given." - man 3 printf
		NOTES:	- Left padding will only be noticed if something else comes after, since all you get is extra blank spaces at the right
		of the conversion specifier 
	- '0' : "Zero padding.  For all conversions except n, the converted value is
			padded on the left with zeros rather than blanks.  If a precision is
			given with a numeric conversion (d, i, o, u, i, x, and X), the 0 flag is
			ignored." - man 3 printf
	- '.' :	"An optional precision, in the form of a period . followed by an optional digit
			string.  If the digit string is omitted, the precision is taken as zero.  This gives
			the minimum number of digits to appear for d, i, o, u, x, and X conversions, the num-
			ber of digits to appear after the decimal-point for a, A, e, E, f, and F conversions,
			the maximum number of significant digits for g and G conversions, or the maximum num-
			ber of characters to be printed from a string for s conversions." - man 3 printf
	- NOTE:	these seem to only be used in conjunction with a following digit specifier, otherwise a "width" of 0 
			is taken by default.
		- %[flag][digit][conversion specifier]
			e.g. int i = 42; printf("%019d", i) ==> 000000000000000042
BONUS:
	- "h"
	- "hh"
	- "l"
	- "ll"

- "# +" flags:
	- "#" :	"For x and X conversions, a non-zero result has the string `0x' (or `0X' for X conversions)
			prepended to it.  For a, A, e, E, f, F, g, and G conversions, the result will always contain a decimal
			point, even if no digits follow it (normally, a decimal point appears in the results of those conversions
			only if a digit follows).  For g and G conversions, trailing zeros are not removed from the result as
			they would otherwise be." - man 3 printf
	- " " :	"A blank should be left before a positive number produced by a signed conversion (a, A, d, e, E, f, F, g, G, or i)." - man 3 printf
	- "+" :	"A sign must always be placed before a number produced by a signed conversion.
			A "+" overrides a space if both are used." - man 3 printf


- modifiers

- arguments (cspdiuxX%) (eE, fF, gG, o)
	- cspdiuxX%
	- %d & %i:
		%d and %i behave similar with printf
		%d and %i behavior is different in scanf
			 "%d and %i behave similar with printf%d assume base 10 while %i auto detects the base. 
			 Therefore, both specifiers behaves differently while they are used with an input specifier. So, 012 would be 10 with %i but 12 with %d. 

    		- %d takes integer value as signed decimal integer i.e. it takes negative values along with positive values but values should be in 
			decimal otherwise it will print garbage value.( Note: if input is in octal format like:012 then %d will ignore 0 and take input as 12)
     
    		- %i takes integer value as integer value with decimal, hexadecimal or octal type. To enter a value in hexadecimal format – 
			value should be provided by preceding “0x” and value in octal format – value should be provided by preceding “0”." - https://www.geeksforgeeks.org/difference-d-format-specifier-c-language/

- VA_ARG (STDARG)

NOTES:
- list of proceeding :
	- Set up va_arg, play with it a bit
	- set up % conversions ; best way to see if my function works at all
	- do individual conversions for eah variable type
	- Set up flag conversions; 
		- "-0." must be used in conjuncture
		- " ", "+", "#" must be used separately
	- Implement a static (global?) variable to count the amount of characters printed; 
		alternatively could convert to a string before outputting and simply counting the resulting string ; might be safer.

Additional bonuses:
- long
- long long ( + wchar_t conversions)
- h && H
- float (3 conversions) e, f, g
- n flag